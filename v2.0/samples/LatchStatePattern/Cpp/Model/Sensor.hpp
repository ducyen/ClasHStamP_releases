#pragma once
/* File generated by Đức's ClasHStamP */
#include "Generic/CommonInclude.h"
#include "Model/Context.hpp"                                    
#include "Generic/Statemachine.h"

class Sensor: public Context{
    public: int getData(
    ){
        return .99;
    } /* Sensor.getData */
    public: void doLongComputationOnData(
        int _x
    ){
    } /* Sensor.doLongComputationOnData */
    public: void doEvenMoreProcessing(
    ){
    } /* Sensor.doEvenMoreProcessing */
    public: enum _EventId {
        evClearDataLatch,
        evDataComplete,
        evDataReady,
        evHasNewData,
        evSensorReset,
        tm_100,
        evNum
    };
    const std::string EventId_toString( _EventId value );
    friend class Main;
    class LatchStm: public Statemachine {
    public:
        class LatchTop: public TopState{ using TThisState = LatchTop;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
        };
        class InitPt: public Pseudostate<InitPt>{};
        class NoData: public LatchTop { using TThisState = NoData; using TSuperState = LatchTop;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
            virtual void Entry( Context* pContext, Statemachine* pStm ){
                if( pStm->IsEnterable<TThisState>() ){
                    std::cout << typeid(this).name() << " entry\n";
                }
            }
            virtual bool EventProc( Context* pContext, Statemachine* pStm, EventId nEventId, EventParams* pParams ){
                bool bResult = false;
                pStm->m_pSourceState = TThisState::GetInstance();
                switch( nEventId ){
                case evHasNewData:{
                    pStm->BgnTrans( pContext, HasNewData::GetInstance() );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } break;
                default: break;
                }
                return bResult;
            }
            virtual void Exit(Context* pContext, Statemachine* pStm) {
                if (pStm->IsExitable<TThisState>()) {
                    std::cout << typeid(this).name() << " exit\n";
                }
            }
        };
        class HasNewData: public LatchTop { using TThisState = HasNewData; using TSuperState = LatchTop;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
            virtual void Entry( Context* pContext, Statemachine* pStm ){
                if( pStm->IsEnterable<TThisState>() ){
                    std::cout << typeid(this).name() << " entry\n";
                }
            }
            virtual bool EventProc( Context* pContext, Statemachine* pStm, EventId nEventId, EventParams* pParams ){
                bool bResult = false;
                pStm->m_pSourceState = TThisState::GetInstance();
                switch( nEventId ){
                case evClearDataLatch:{
                    pStm->BgnTrans( pContext, NoData::GetInstance() );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } break;
                default: break;
                }
                return bResult;
            }
            virtual void Exit(Context* pContext, Statemachine* pStm) {
                if (pStm->IsExitable<TThisState>()) {
                    std::cout << typeid(this).name() << " exit\n";
                }
            }
        };
        virtual bool DefaultTrans( Context* pContext ){
            bool bResult = false;
            Statemachine* pStm = this;
            do {
                if (m_pCurrentState == LatchTop::GetInstance() && m_pPseudostate == LatchStm::InitPt::GetInstance()) {
                    pStm->BgnTrans( pContext, NoData::GetInstance() );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } else if (m_pCurrentState != m_pPseudostate && dynamic_cast<LatchTop*>(m_pPseudostate) != NULL) {
                    pStm->BgnTrans( pContext, dynamic_cast<TopState*>(m_pPseudostate) );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } else {
                }
            } while (false);
            return bResult;
        }
        virtual bool Reset(Context* pContext, Statemachine* pParentStm, StateBase* pEntryPoint) {
            m_pParentStm = pParentStm;
            if (pEntryPoint == null) {
                if (IsFinished()) {
                    m_pPseudostate = InitPt::GetInstance();
                }
            } else {
                if (IsFinished()) {
                    m_pPseudostate = pEntryPoint;
                    return false;
                } else {
                    m_pPseudostate = pEntryPoint;
                }                    
            }
            if (pEntryPoint != null) {
            }
            return RunToCompletion(pContext);
        }
        virtual bool EventProc(Context* pContext, int nEventId, EventParams* pParams){
            bool bResult = false;
            m_pLCAState = TopState::GetInstance();
            bResult = m_pCurrentState->EventProc(pContext, this, nEventId, pParams);
            RunToCompletion(pContext);
            return bResult;
        }
        template<class TCompositeState = TopState>
        bool IsInRecur() {
            if (IsIn<TCompositeState>()) { return true; }
            return false;
        }
        virtual bool Abort(Context* pContext) {
            m_pSourceState = LatchTop::GetInstance();
            BgnTrans(pContext, LatchTop::GetInstance());
            EndTrans(pContext);
            return true;
        }
        virtual bool IsFinished() {
            return m_pCurrentState == LatchTop::GetInstance() && m_pCurrentState == m_pPseudostate;
        }
        LatchStm(): Statemachine(LatchTop::GetInstance(), LatchTop::GetInstance()) {}
    };
    class DepedentStm: public Statemachine {
    public:
        class DependentTop: public TopState{ using TThisState = DependentTop;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
        };
        LatchStm m_LatchLatchStm;                               
        class InitPt: public Pseudostate<InitPt>{};
        class Dependent: public DependentTop { using TThisState = Dependent; using TSuperState = DependentTop;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
            virtual void Entry( Context* pContext, Statemachine* pStm ){
                if( pStm->IsEnterable<TThisState>() ){
                    std::cout << typeid(this).name() << " entry\n";
                    ((DepedentStm*)pStm)->m_LatchLatchStm.Reset( pContext, pStm, nullptr );
                }
            }
            virtual bool EventProc( Context* pContext, Statemachine* pStm, EventId nEventId, EventParams* pParams ){
                bool bResult = false;
                pStm->m_pSourceState = TThisState::GetInstance();
                return bResult;
            }
            virtual void Exit(Context* pContext, Statemachine* pStm) {
                if (pStm->IsExitable<TThisState>()) {
                    ((DepedentStm*)pStm)->m_LatchLatchStm.Abort( pContext );
                    std::cout << typeid(this).name() << " exit\n";
                }
            }
        };
        class ProcessingData: public Dependent { using TThisState = ProcessingData; using TSuperState = Dependent;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
            virtual void Entry( Context* pContext, Statemachine* pStm ){
                if( pStm->IsEnterable<TThisState>() ){
                    TSuperState::Entry( pContext, pStm );
                    std::cout << typeid(this).name() << " entry\n";
                    DisplayMsg("doLongComputationOnData(((Sensor)pContext).x);");
                }
            }
            virtual bool EventProc( Context* pContext, Statemachine* pStm, EventId nEventId, EventParams* pParams ){
                bool bResult = false;
                pStm->m_pSourceState = TThisState::GetInstance();
                return bResult ? bResult : TSuperState::EventProc( pContext, pStm, nEventId, pParams );
            }
            virtual void Exit(Context* pContext, Statemachine* pStm) {
                if (pStm->IsExitable<TThisState>()) {
                    std::cout << typeid(this).name() << " exit\n";
                    TSuperState::Exit(pContext, pStm);
                }
            }
        };
        class MoreProcessing: public Dependent { using TThisState = MoreProcessing; using TSuperState = Dependent;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
            virtual void Entry( Context* pContext, Statemachine* pStm ){
                if( pStm->IsEnterable<TThisState>() ){
                    TSuperState::Entry( pContext, pStm );
                    std::cout << typeid(this).name() << " entry\n";
                    DisplayMsg("doEvenMoreProcessing();");
                }
            }
            virtual bool EventProc( Context* pContext, Statemachine* pStm, EventId nEventId, EventParams* pParams ){
                bool bResult = false;
                pStm->m_pSourceState = TThisState::GetInstance();
                return bResult ? bResult : TSuperState::EventProc( pContext, pStm, nEventId, pParams );
            }
            virtual void Exit(Context* pContext, Statemachine* pStm) {
                if (pStm->IsExitable<TThisState>()) {
                    std::cout << typeid(this).name() << " exit\n";
                    TSuperState::Exit(pContext, pStm);
                }
            }
        };
        class ReadyToProcessData: public Dependent { using TThisState = ReadyToProcessData; using TSuperState = Dependent;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
            virtual void Entry( Context* pContext, Statemachine* pStm ){
                if( pStm->IsEnterable<TThisState>() ){
                    TSuperState::Entry( pContext, pStm );
                    std::cout << typeid(this).name() << " entry\n";
                }
            }
            virtual bool EventProc( Context* pContext, Statemachine* pStm, EventId nEventId, EventParams* pParams ){
                bool bResult = false;
                pStm->m_pSourceState = TThisState::GetInstance();
                switch( nEventId ){
                case tm_100:{
                    if (((Sensor*)pContext)->IsIn<LatchStm::HasNewData>()) {
                        pStm->BgnTrans( pContext, ProcessingData::GetInstance() );
                        ((DepedentStm*)pStm)->m_LatchLatchStm.Reset(pContext, pStm, LatchStm::NoData::GetInstance());
                        pStm->EndTrans( pContext );
                        bResult = true;
                    }
                    else {
                        pStm->m_bIsExternTrans = true;
                        pStm->BgnTrans( pContext, ReadyToProcessData::GetInstance() );
                        pStm->EndTrans( pContext );
                        bResult = true;
                    }
                } break;
                default: break;
                }
                return bResult ? bResult : TSuperState::EventProc( pContext, pStm, nEventId, pParams );
            }
            virtual void Exit(Context* pContext, Statemachine* pStm) {
                if (pStm->IsExitable<TThisState>()) {
                    std::cout << typeid(this).name() << " exit\n";
                    TSuperState::Exit(pContext, pStm);
                }
            }
        };
        virtual bool DefaultTrans( Context* pContext ){
            bool bResult = false;
            Statemachine* pStm = this;
            bResult |= m_LatchLatchStm.DefaultTrans( pContext );
            do {
                if (m_pCurrentState == Dependent::GetInstance() && m_pPseudostate == DepedentStm::InitPt::GetInstance()) {
                    pStm->BgnTrans( pContext, ReadyToProcessData::GetInstance() );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } else if (m_pPseudostate == DepedentStm::ProcessingData::GetInstance()) {
                    pStm->BgnTrans( pContext, MoreProcessing::GetInstance() );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } else if (m_pPseudostate == DepedentStm::MoreProcessing::GetInstance()) {
                    pStm->BgnTrans( pContext, ReadyToProcessData::GetInstance() );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } else if (m_pCurrentState == DependentTop::GetInstance() && m_pPseudostate == DepedentStm::InitPt::GetInstance()) {
                    pStm->BgnTrans( pContext, Dependent::GetInstance(), InitPt::GetInstance() );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } else if (m_pCurrentState != m_pPseudostate && dynamic_cast<DependentTop*>(m_pPseudostate) != NULL) {
                    pStm->BgnTrans( pContext, dynamic_cast<TopState*>(m_pPseudostate) );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } else {
                }
            } while (false);
            return bResult;
        }
        virtual bool Reset(Context* pContext, Statemachine* pParentStm, StateBase* pEntryPoint) {
            m_pParentStm = pParentStm;
            if (pEntryPoint == null) {
                if (IsFinished()) {
                    m_pPseudostate = InitPt::GetInstance();
                }
            } else {
                if (IsFinished()) {
                    m_pPseudostate = pEntryPoint;
                    return false;
                } else {
                    m_pPseudostate = pEntryPoint;
                }                    
            }
            if (pEntryPoint != null) {
                m_LatchLatchStm.Reset( pContext, this, pEntryPoint );
            }
            return RunToCompletion(pContext);
        }
        virtual bool EventProc(Context* pContext, int nEventId, EventParams* pParams){
            bool bResult = false;
            m_pLCAState = TopState::GetInstance();
            bResult |= m_LatchLatchStm.EventProc( pContext, nEventId, pParams );
            bResult = m_pCurrentState->EventProc(pContext, this, nEventId, pParams);
            RunToCompletion(pContext);
            return bResult;
        }
        template<class TCompositeState = TopState>
        bool IsInRecur() {
            if (!m_LatchLatchStm.IsIn<TCompositeState>()) { return true; }
            if (IsIn<TCompositeState>()) { return true; }
            return false;
        }
        virtual bool Abort(Context* pContext) {
            m_pSourceState = DependentTop::GetInstance();
            BgnTrans(pContext, DependentTop::GetInstance());
            EndTrans(pContext);
            return true;
        }
        virtual bool IsFinished() {
            return m_pCurrentState == DependentTop::GetInstance() && m_pCurrentState == m_pPseudostate;
        }
        DepedentStm(): Statemachine(DependentTop::GetInstance(), DependentTop::GetInstance()) {}
    };
    class PredicateStm: public Statemachine {
    public:
        class PredicateTop: public TopState{ using TThisState = PredicateTop;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
        };
        DepedentStm m_DependentDepedentStm;                     
        class InitPt: public Pseudostate<InitPt>{};
        class SensorActive: public PredicateTop { using TThisState = SensorActive; using TSuperState = PredicateTop;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
            virtual void Entry( Context* pContext, Statemachine* pStm ){
                if( pStm->IsEnterable<TThisState>() ){
                    std::cout << typeid(this).name() << " entry\n";
                    ((PredicateStm*)pStm)->m_DependentDepedentStm.Reset( pContext, pStm, nullptr );
                }
            }
            virtual bool EventProc( Context* pContext, Statemachine* pStm, EventId nEventId, EventParams* pParams ){
                bool bResult = false;
                pStm->m_pSourceState = TThisState::GetInstance();
                return bResult;
            }
            virtual void Exit(Context* pContext, Statemachine* pStm) {
                if (pStm->IsExitable<TThisState>()) {
                    ((PredicateStm*)pStm)->m_DependentDepedentStm.Abort( pContext );
                    std::cout << typeid(this).name() << " exit\n";
                }
            }
        };
        class WaitingForData: public SensorActive { using TThisState = WaitingForData; using TSuperState = SensorActive;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
            virtual void Entry( Context* pContext, Statemachine* pStm ){
                if( pStm->IsEnterable<TThisState>() ){
                    TSuperState::Entry( pContext, pStm );
                    std::cout << typeid(this).name() << " entry\n";
                }
            }
            virtual bool EventProc( Context* pContext, Statemachine* pStm, EventId nEventId, EventParams* pParams ){
                bool bResult = false;
                pStm->m_pSourceState = TThisState::GetInstance();
                switch( nEventId ){
                case evDataReady:{
                    DisplayMsg("x = .getData();");
                    if (((Sensor*)pContext)->IsIn<LatchStm::NoData>()) {
                        pStm->BgnTrans( pContext, DataReady::GetInstance() );
                        ((PredicateStm*)pStm)->m_DependentDepedentStm.Reset(pContext, pStm, LatchStm::HasNewData::GetInstance());
                        pStm->EndTrans( pContext );
                        bResult = true;
                    }
                    else {
                        pStm->BgnTrans( pContext, DataReady::GetInstance() );
                        pStm->EndTrans( pContext );
                        bResult = true;
                    }
                } break;
                default: break;
                }
                return bResult ? bResult : TSuperState::EventProc( pContext, pStm, nEventId, pParams );
            }
            virtual void Exit(Context* pContext, Statemachine* pStm) {
                if (pStm->IsExitable<TThisState>()) {
                    std::cout << typeid(this).name() << " exit\n";
                    TSuperState::Exit(pContext, pStm);
                }
            }
        };
        class DataReady: public SensorActive { using TThisState = DataReady; using TSuperState = SensorActive;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
            virtual void Entry( Context* pContext, Statemachine* pStm ){
                if( pStm->IsEnterable<TThisState>() ){
                    TSuperState::Entry( pContext, pStm );
                    std::cout << typeid(this).name() << " entry\n";
                }
            }
            virtual bool EventProc( Context* pContext, Statemachine* pStm, EventId nEventId, EventParams* pParams ){
                bool bResult = false;
                pStm->m_pSourceState = TThisState::GetInstance();
                switch( nEventId ){
                case evDataComplete:{
                    pStm->BgnTrans( pContext, ResetingSensor::GetInstance() );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } break;
                default: break;
                }
                return bResult ? bResult : TSuperState::EventProc( pContext, pStm, nEventId, pParams );
            }
            virtual void Exit(Context* pContext, Statemachine* pStm) {
                if (pStm->IsExitable<TThisState>()) {
                    std::cout << typeid(this).name() << " exit\n";
                    TSuperState::Exit(pContext, pStm);
                }
            }
        };
        class ResetingSensor: public SensorActive { using TThisState = ResetingSensor; using TSuperState = SensorActive;
            public: static TopState* GetInstance() { static TThisState singleInstance; return &singleInstance; }
            virtual void Entry( Context* pContext, Statemachine* pStm ){
                if( pStm->IsEnterable<TThisState>() ){
                    TSuperState::Entry( pContext, pStm );
                    std::cout << typeid(this).name() << " entry\n";
                }
            }
            virtual bool EventProc( Context* pContext, Statemachine* pStm, EventId nEventId, EventParams* pParams ){
                bool bResult = false;
                pStm->m_pSourceState = TThisState::GetInstance();
                switch( nEventId ){
                case evSensorReset:{
                    pStm->BgnTrans( pContext, WaitingForData::GetInstance() );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } break;
                default: break;
                }
                return bResult ? bResult : TSuperState::EventProc( pContext, pStm, nEventId, pParams );
            }
            virtual void Exit(Context* pContext, Statemachine* pStm) {
                if (pStm->IsExitable<TThisState>()) {
                    std::cout << typeid(this).name() << " exit\n";
                    TSuperState::Exit(pContext, pStm);
                }
            }
        };
        virtual bool DefaultTrans( Context* pContext ){
            bool bResult = false;
            Statemachine* pStm = this;
            bResult |= m_DependentDepedentStm.DefaultTrans( pContext );
            do {
                if (m_pCurrentState == SensorActive::GetInstance() && m_pPseudostate == PredicateStm::InitPt::GetInstance()) {
                    pStm->BgnTrans( pContext, WaitingForData::GetInstance() );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } else if (m_pCurrentState == PredicateTop::GetInstance() && m_pPseudostate == PredicateStm::InitPt::GetInstance()) {
                    pStm->BgnTrans( pContext, SensorActive::GetInstance(), InitPt::GetInstance() );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } else if (m_pCurrentState != m_pPseudostate && dynamic_cast<PredicateTop*>(m_pPseudostate) != NULL) {
                    pStm->BgnTrans( pContext, dynamic_cast<TopState*>(m_pPseudostate) );
                    pStm->EndTrans( pContext );
                    bResult = true;
                } else {
                }
            } while (false);
            return bResult;
        }
        virtual bool Reset(Context* pContext, Statemachine* pParentStm, StateBase* pEntryPoint) {
            m_pParentStm = pParentStm;
            if (pEntryPoint == null) {
                if (IsFinished()) {
                    m_pPseudostate = InitPt::GetInstance();
                }
            } else {
                if (IsFinished()) {
                    m_pPseudostate = pEntryPoint;
                    return false;
                } else {
                    m_pPseudostate = pEntryPoint;
                }                    
            }
            if (pEntryPoint != null) {
                m_DependentDepedentStm.Reset( pContext, this, pEntryPoint );
            }
            return RunToCompletion(pContext);
        }
        virtual bool EventProc(Context* pContext, int nEventId, EventParams* pParams){
            bool bResult = false;
            m_pLCAState = TopState::GetInstance();
            bResult |= m_DependentDepedentStm.EventProc( pContext, nEventId, pParams );
            bResult = m_pCurrentState->EventProc(pContext, this, nEventId, pParams);
            RunToCompletion(pContext);
            return bResult;
        }
        template<class TCompositeState = TopState>
        bool IsInRecur() {
            if (!m_DependentDepedentStm.IsIn<TCompositeState>()) { return true; }
            if (IsIn<TCompositeState>()) { return true; }
            return false;
        }
        virtual bool Abort(Context* pContext) {
            m_pSourceState = PredicateTop::GetInstance();
            BgnTrans(pContext, PredicateTop::GetInstance());
            EndTrans(pContext);
            return true;
        }
        virtual bool IsFinished() {
            return m_pCurrentState == PredicateTop::GetInstance() && m_pCurrentState == m_pPseudostate;
        }
        PredicateStm(): Statemachine(PredicateTop::GetInstance(), PredicateTop::GetInstance()) {}
    };
    public:  Sensor(
        int _attribute0
    ):  Context( _attribute0 ),
        x( 0 )
    {
    }                                                                                           
    private: int x;                                             
    PredicateStm mainStm;                                       
public:
    bool Start() {
        mainStm.Abort(this);
        return mainStm.Reset(this, nullptr, nullptr);
    }
    bool EventProc(EventId nEventId, EventParams* pParams) {
        return mainStm.EventProc(this, nEventId, pParams);
    }
    template<class TState>
    bool IsIn() {
        return mainStm.IsInRecur<TState>();
    }
};
