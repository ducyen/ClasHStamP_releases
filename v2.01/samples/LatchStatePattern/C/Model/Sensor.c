/* File generated by Đức's ClasHStamP */
#define __Sensor_INTERNAL__
#include "CommonInclude.h"
#include "Sensor.h"
/** @public @memberof Sensor */
int Sensor_getData(
    Sensor* pSensor
){
    return .99;
} /* Sensor_getData */

/** @public @memberof Sensor */
void Sensor_doLongComputationOnData(
    Sensor* pSensor,
    int _x
){
} /* Sensor_doLongComputationOnData */

/** @public @memberof Sensor */
void Sensor_doEvenMoreProcessing(
    Sensor* pSensor
){
} /* Sensor_doEvenMoreProcessing */

const TCHAR* SensorEvent_toString( Sensor_EVENT value ){
    switch( value ){
    case Sensor_evClearDataLatch: return _T( "evClearDataLatch" );
    case Sensor_evDataComplete: return _T( "evDataComplete" );
    case Sensor_evDataReady: return _T( "evDataReady" );
    case Sensor_evHasNewData: return _T( "evHasNewData" );
    case Sensor_evSensorReset: return _T( "evSensorReset" );
    case Sensor_tm_100: return _T( "tm_100" );
    default: return _T( "Sensor_UNKNOWN" );
    }
}
static void LatchStm_BgnTrans( Sensor *pLatchTop, LatchStm* pStm, UINT32 targetState, UINT32 initState );
static void LatchStm_EndTrans( Sensor *pLatchTop, LatchStm* pStm );
static BOOL LatchStm_Reset( Sensor* pLatchTop, LatchStm* pStm, HdStateMachine* pParentStm, UINT32 nEntryPoint );
static BOOL LatchStm_Abort( Sensor* pLatchTop, LatchStm* pStm );
static BOOL LatchStm_EventProc( Sensor* pLatchTop, LatchStm* pStm, Sensor_EVENT nEventId, void* pEventParams );
static BOOL LatchStm_RunToCompletion( Sensor* pLatchTop, LatchStm* pStm );
static void LatchStm_NoData_Entry( Sensor* pSensor, LatchStm* pStm ){
    if( HdStateMachine_Enterable( &pStm->base, LatchStm_NoData ) ){
        printf( "%s\n", __FUNCTION__ );
    }
}
static BOOL LatchStm_NoData_EventProc( Sensor* pSensor, LatchStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = LatchStm_NoData;
    switch( nEventId ){
    case Sensor_evHasNewData:{
        LatchStm_BgnTrans( pSensor, pStm, LatchStm_HasNewData, STATE_UNDEF );
        LatchStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    } break;
    default: break;
    }
    return bResult;
}
static void LatchStm_NoData_Exit( Sensor* pSensor, LatchStm* pStm ){
    if( HdStateMachine_Exitable( &pStm->base, LatchStm_NoData ) ){ 
        printf( "%s\n", __FUNCTION__ );
    }
}
static void LatchStm_HasNewData_Entry( Sensor* pSensor, LatchStm* pStm ){
    if( HdStateMachine_Enterable( &pStm->base, LatchStm_HasNewData ) ){
        printf( "%s\n", __FUNCTION__ );
    }
}
static BOOL LatchStm_HasNewData_EventProc( Sensor* pSensor, LatchStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = LatchStm_HasNewData;
    switch( nEventId ){
    case Sensor_evClearDataLatch:{
        LatchStm_BgnTrans( pSensor, pStm, LatchStm_NoData, STATE_UNDEF );
        LatchStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    } break;
    default: break;
    }
    return bResult;
}
static void LatchStm_HasNewData_Exit( Sensor* pSensor, LatchStm* pStm ){
    if( HdStateMachine_Exitable( &pStm->base, LatchStm_HasNewData ) ){ 
        printf( "%s\n", __FUNCTION__ );
    }
}
static void LatchStm_EndTrans( Sensor *pSensor, LatchStm* pStm ){
    pStm->base.nCurrentState = pStm->base.nTargetState;
    pStm->base.bIsExternTrans = FALSE;
    switch( pStm->base.nCurrentState ){
    case LatchStm_NoData:       LatchStm_NoData_Entry( pSensor, pStm ); break;
    case LatchStm_HasNewData:   LatchStm_HasNewData_Entry( pSensor, pStm ); break;
    default: break;
    }
}
static void LatchStm_BgnTrans( Sensor *pSensor, LatchStm* pStm, UINT32 targetState, UINT32 initState ){
    pStm->base.nTargetState = targetState;
    pStm->base.nPseudostate = targetState;
    if( initState ){
        pStm->base.nPseudostate = initState;
    }
    switch( pStm->base.nCurrentState ){
    case LatchStm_NoData:       LatchStm_NoData_Exit( pSensor, pStm ); break;
    case LatchStm_HasNewData:   LatchStm_HasNewData_Exit( pSensor, pStm ); break;
    default: break;
    }
}
static BOOL LatchStm_StateDefaultTrans( Sensor* pSensor, LatchStm* pStm ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = pStm->base.nCurrentState;
    pStm->base.nLCAState = STATE_UNDEF;
    do{   if( pStm->base.nCurrentState == LatchStm_LatchTop && pStm->base.nPseudostate == LatchStm_InitPt ){
        LatchStm_BgnTrans( pSensor, pStm, LatchStm_NoData, STATE_UNDEF );
        LatchStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    }else if( pStm->base.nCurrentState != pStm->base.nPseudostate && IS_IN(pStm->base.nPseudostate, LatchStm_LatchTop) ){
        LatchStm_BgnTrans( pSensor, pStm, pStm->base.nPseudostate, STATE_UNDEF );
        LatchStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    }else{
    }   }while( FALSE );
    return bResult;
}
static BOOL LatchStm_RunToCompletion( Sensor* pSensor, LatchStm* pStm ){
    BOOL bResult;
    do{
        bResult = LatchStm_StateDefaultTrans( pSensor, pStm );
    } while ( bResult );
    return bResult;
}
static BOOL LatchStm_Reset( Sensor* pSensor, LatchStm* pStm, HdStateMachine* pParentStm, UINT32 nEntryPoint ) {
    pStm->base.pParentStm = pParentStm;
    if( nEntryPoint == NULL ){
        if( LatchStm_IsFinished( &pStm->base ) ){
            pStm->base.nPseudostate = LatchStm_InitPt;
        }
    }else{
        if( LatchStm_IsFinished( &pStm->base ) ){
            pStm->base.nPseudostate = nEntryPoint;
            return FALSE;
        }else{
            pStm->base.nPseudostate = nEntryPoint;
        }
    }
    if( nEntryPoint != STATE_UNDEF && nEntryPoint <= STATE_TOP ){
    }
    return LatchStm_RunToCompletion( pSensor, pStm );
}
static BOOL LatchStm_EventProc( Sensor* pSensor, LatchStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nLCAState = STATE_UNDEF;
    switch( pStm->base.nCurrentState ){
    case LatchStm_NoData:                       bResult |= LatchStm_NoData_EventProc( pSensor, pStm, nEventId, pEventParams ); break;
    case LatchStm_HasNewData:                   bResult |= LatchStm_HasNewData_EventProc( pSensor, pStm, nEventId, pEventParams ); break;
    default: break;
    }
    LatchStm_RunToCompletion( pSensor, pStm );
    return bResult;
}
static BOOL LatchStm_IsIn( LatchStm* pStm, UINT32 nCompositeState ) {
    if( IS_IN( pStm->base.nCurrentState, nCompositeState ) ){ return TRUE; }
    return FALSE;
}
static BOOL LatchStm_Abort( Sensor* pSensor, LatchStm* pStm ) {
    pStm->base.nSourceState = LatchStm_LatchTop;
    LatchStm_BgnTrans( pSensor, pStm, LatchStm_LatchTop, STATE_UNDEF );
    LatchStm_EndTrans( pSensor, pStm );
    return TRUE;
}
int LatchStm_IsFinished(LatchStm* pLatchStm){
    return pLatchStm->base.nCurrentState == LatchStm_LatchTop && pLatchStm->base.nCurrentState == pLatchStm->base.nPseudostate;
}
static void DepedentStm_BgnTrans( Sensor *pDependentTop, DepedentStm* pStm, UINT32 targetState, UINT32 initState );
static void DepedentStm_EndTrans( Sensor *pDependentTop, DepedentStm* pStm );
static BOOL DepedentStm_Reset( Sensor* pDependentTop, DepedentStm* pStm, HdStateMachine* pParentStm, UINT32 nEntryPoint );
static BOOL DepedentStm_Abort( Sensor* pDependentTop, DepedentStm* pStm );
static BOOL DepedentStm_EventProc( Sensor* pDependentTop, DepedentStm* pStm, Sensor_EVENT nEventId, void* pEventParams );
static BOOL DepedentStm_RunToCompletion( Sensor* pDependentTop, DepedentStm* pStm );
static void DepedentStm_Dependent_Entry( Sensor* pSensor, DepedentStm* pStm ){
    if( HdStateMachine_Enterable( &pStm->base, DepedentStm_Dependent ) ){
        printf( "%s\n", __FUNCTION__ );
        LatchStm_Reset( pSensor, &pStm->LatchLatchStm, &pStm->base, STATE_UNDEF );
    }
}
static BOOL DepedentStm_Dependent_EventProc( Sensor* pSensor, DepedentStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = DepedentStm_Dependent;
    return bResult;
}
static void DepedentStm_Dependent_Exit( Sensor* pSensor, DepedentStm* pStm ){
    if( HdStateMachine_Exitable( &pStm->base, DepedentStm_Dependent ) ){ 
        LatchStm_Abort( pSensor, &pStm->LatchLatchStm );
        printf( "%s\n", __FUNCTION__ );
    }
}
static void DepedentStm_ProcessingData_Entry( Sensor* pSensor, DepedentStm* pStm ){
    if( HdStateMachine_Enterable( &pStm->base, DepedentStm_ProcessingData ) ){
        DepedentStm_Dependent_Entry( pSensor, pStm );
        printf( "%s\n", __FUNCTION__ );
        DisplayMsg("doLongComputationOnData(((Sensor)pContext).x);");
    }
}
static BOOL DepedentStm_ProcessingData_EventProc( Sensor* pSensor, DepedentStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = DepedentStm_ProcessingData;
    return bResult ? bResult : DepedentStm_Dependent_EventProc( pSensor, pStm, nEventId, pEventParams );
}
static void DepedentStm_ProcessingData_Exit( Sensor* pSensor, DepedentStm* pStm ){
    if( HdStateMachine_Exitable( &pStm->base, DepedentStm_ProcessingData ) ){ 
        printf( "%s\n", __FUNCTION__ );
        DepedentStm_Dependent_Exit( pSensor, pStm );
    }
}
static void DepedentStm_MoreProcessing_Entry( Sensor* pSensor, DepedentStm* pStm ){
    if( HdStateMachine_Enterable( &pStm->base, DepedentStm_MoreProcessing ) ){
        DepedentStm_Dependent_Entry( pSensor, pStm );
        printf( "%s\n", __FUNCTION__ );
        DisplayMsg("doEvenMoreProcessing();");
    }
}
static BOOL DepedentStm_MoreProcessing_EventProc( Sensor* pSensor, DepedentStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = DepedentStm_MoreProcessing;
    return bResult ? bResult : DepedentStm_Dependent_EventProc( pSensor, pStm, nEventId, pEventParams );
}
static void DepedentStm_MoreProcessing_Exit( Sensor* pSensor, DepedentStm* pStm ){
    if( HdStateMachine_Exitable( &pStm->base, DepedentStm_MoreProcessing ) ){ 
        printf( "%s\n", __FUNCTION__ );
        DepedentStm_Dependent_Exit( pSensor, pStm );
    }
}
static void DepedentStm_ReadyToProcessData_Entry( Sensor* pSensor, DepedentStm* pStm ){
    if( HdStateMachine_Enterable( &pStm->base, DepedentStm_ReadyToProcessData ) ){
        DepedentStm_Dependent_Entry( pSensor, pStm );
        printf( "%s\n", __FUNCTION__ );
    }
}
static BOOL DepedentStm_ReadyToProcessData_EventProc( Sensor* pSensor, DepedentStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = DepedentStm_ReadyToProcessData;
    switch( nEventId ){
    case Sensor_tm_100:{
        if (Sensor_IsIn( pSensor, LatchStm_HasNewData )) {
            DepedentStm_BgnTrans( pSensor, pStm, DepedentStm_ProcessingData, STATE_UNDEF );
            LatchStm_Reset( pSensor, &pStm->LatchLatchStm, &pStm->base, LatchStm_NoData );
            DepedentStm_EndTrans( pSensor, pStm );
            bResult = TRUE;
        }
        else {
            pStm->base.bIsExternTrans = TRUE;
            DepedentStm_BgnTrans( pSensor, pStm, DepedentStm_ReadyToProcessData, STATE_UNDEF );
            DepedentStm_EndTrans( pSensor, pStm );
            bResult = TRUE;
        }
    } break;
    default: break;
    }
    return bResult ? bResult : DepedentStm_Dependent_EventProc( pSensor, pStm, nEventId, pEventParams );
}
static void DepedentStm_ReadyToProcessData_Exit( Sensor* pSensor, DepedentStm* pStm ){
    if( HdStateMachine_Exitable( &pStm->base, DepedentStm_ReadyToProcessData ) ){ 
        printf( "%s\n", __FUNCTION__ );
        DepedentStm_Dependent_Exit( pSensor, pStm );
    }
}
static void DepedentStm_EndTrans( Sensor *pSensor, DepedentStm* pStm ){
    pStm->base.nCurrentState = pStm->base.nTargetState;
    pStm->base.bIsExternTrans = FALSE;
    switch( pStm->base.nCurrentState ){
    case DepedentStm_Dependent: DepedentStm_Dependent_Entry( pSensor, pStm ); break;
    case DepedentStm_ProcessingData:DepedentStm_ProcessingData_Entry( pSensor, pStm ); break;
    case DepedentStm_MoreProcessing:DepedentStm_MoreProcessing_Entry( pSensor, pStm ); break;
    case DepedentStm_ReadyToProcessData:DepedentStm_ReadyToProcessData_Entry( pSensor, pStm ); break;
    default: break;
    }
}
static void DepedentStm_BgnTrans( Sensor *pSensor, DepedentStm* pStm, UINT32 targetState, UINT32 initState ){
    pStm->base.nTargetState = targetState;
    pStm->base.nPseudostate = targetState;
    if( initState ){
        pStm->base.nPseudostate = initState;
    }
    switch( pStm->base.nCurrentState ){
    case DepedentStm_Dependent: DepedentStm_Dependent_Exit( pSensor, pStm ); break;
    case DepedentStm_ProcessingData:DepedentStm_ProcessingData_Exit( pSensor, pStm ); break;
    case DepedentStm_MoreProcessing:DepedentStm_MoreProcessing_Exit( pSensor, pStm ); break;
    case DepedentStm_ReadyToProcessData:DepedentStm_ReadyToProcessData_Exit( pSensor, pStm ); break;
    default: break;
    }
}
static BOOL DepedentStm_StateDefaultTrans( Sensor* pSensor, DepedentStm* pStm ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = pStm->base.nCurrentState;
    pStm->base.nLCAState = STATE_UNDEF;
    bResult |= LatchStm_StateDefaultTrans( pSensor, &pStm->LatchLatchStm );
    do{   if( pStm->base.nCurrentState == DepedentStm_Dependent && pStm->base.nPseudostate == DepedentStm_InitPt ){
        DepedentStm_BgnTrans( pSensor, pStm, DepedentStm_ReadyToProcessData, STATE_UNDEF );
        DepedentStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    }else if( pStm->base.nPseudostate == DepedentStm_ProcessingData ){
        DepedentStm_BgnTrans( pSensor, pStm, DepedentStm_MoreProcessing, STATE_UNDEF );
        DepedentStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    }else if( pStm->base.nPseudostate == DepedentStm_MoreProcessing ){
        DepedentStm_BgnTrans( pSensor, pStm, DepedentStm_ReadyToProcessData, STATE_UNDEF );
        DepedentStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    }else if( pStm->base.nCurrentState == DepedentStm_DependentTop && pStm->base.nPseudostate == DepedentStm_InitPt ){
        DepedentStm_BgnTrans( pSensor, pStm, DepedentStm_Dependent, DepedentStm_InitPt );
        DepedentStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    }else if( pStm->base.nCurrentState != pStm->base.nPseudostate && IS_IN(pStm->base.nPseudostate, DepedentStm_DependentTop) ){
        DepedentStm_BgnTrans( pSensor, pStm, pStm->base.nPseudostate, STATE_UNDEF );
        DepedentStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    }else{
    }   }while( FALSE );
    return bResult;
}
static BOOL DepedentStm_RunToCompletion( Sensor* pSensor, DepedentStm* pStm ){
    BOOL bResult;
    do{
        bResult = DepedentStm_StateDefaultTrans( pSensor, pStm );
    } while ( bResult );
    return bResult;
}
static BOOL DepedentStm_Reset( Sensor* pSensor, DepedentStm* pStm, HdStateMachine* pParentStm, UINT32 nEntryPoint ) {
    pStm->base.pParentStm = pParentStm;
    if( nEntryPoint == NULL ){
        if( DepedentStm_IsFinished( &pStm->base ) ){
            pStm->base.nPseudostate = DepedentStm_InitPt;
        }
    }else{
        if( DepedentStm_IsFinished( &pStm->base ) ){
            pStm->base.nPseudostate = nEntryPoint;
            return FALSE;
        }else{
            pStm->base.nPseudostate = nEntryPoint;
        }
    }
    if( nEntryPoint != STATE_UNDEF && nEntryPoint <= STATE_TOP ){
        LatchStm_Reset( pSensor, &pStm->LatchLatchStm, &pStm->base, nEntryPoint );
    }
    return DepedentStm_RunToCompletion( pSensor, pStm );
}
static BOOL DepedentStm_EventProc( Sensor* pSensor, DepedentStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nLCAState = STATE_UNDEF;
    bResult |= LatchStm_EventProc( pSensor, &pStm->LatchLatchStm, nEventId, pEventParams );
    switch( pStm->base.nCurrentState ){
    case DepedentStm_Dependent:                 bResult |= DepedentStm_Dependent_EventProc( pSensor, pStm, nEventId, pEventParams ); break;
    case DepedentStm_ProcessingData:            bResult |= DepedentStm_ProcessingData_EventProc( pSensor, pStm, nEventId, pEventParams ); break;
    case DepedentStm_MoreProcessing:            bResult |= DepedentStm_MoreProcessing_EventProc( pSensor, pStm, nEventId, pEventParams ); break;
    case DepedentStm_ReadyToProcessData:        bResult |= DepedentStm_ReadyToProcessData_EventProc( pSensor, pStm, nEventId, pEventParams ); break;
    default: break;
    }
    DepedentStm_RunToCompletion( pSensor, pStm );
    return bResult;
}
static BOOL DepedentStm_IsIn( DepedentStm* pStm, UINT32 nCompositeState ) {
    if( LatchStm_IsIn( &pStm->LatchLatchStm, nCompositeState ) ){ return TRUE; }
    if( IS_IN( pStm->base.nCurrentState, nCompositeState ) ){ return TRUE; }
    return FALSE;
}
static BOOL DepedentStm_Abort( Sensor* pSensor, DepedentStm* pStm ) {
    pStm->base.nSourceState = DepedentStm_DependentTop;
    DepedentStm_BgnTrans( pSensor, pStm, DepedentStm_DependentTop, STATE_UNDEF );
    DepedentStm_EndTrans( pSensor, pStm );
    return TRUE;
}
int DepedentStm_IsFinished(DepedentStm* pDepedentStm){
    return pDepedentStm->base.nCurrentState == DepedentStm_DependentTop && pDepedentStm->base.nCurrentState == pDepedentStm->base.nPseudostate;
}
static void PredicateStm_BgnTrans( Sensor *pPredicateTop, PredicateStm* pStm, UINT32 targetState, UINT32 initState );
static void PredicateStm_EndTrans( Sensor *pPredicateTop, PredicateStm* pStm );
static BOOL PredicateStm_Reset( Sensor* pPredicateTop, PredicateStm* pStm, HdStateMachine* pParentStm, UINT32 nEntryPoint );
static BOOL PredicateStm_Abort( Sensor* pPredicateTop, PredicateStm* pStm );
static BOOL PredicateStm_EventProc( Sensor* pPredicateTop, PredicateStm* pStm, Sensor_EVENT nEventId, void* pEventParams );
static BOOL PredicateStm_RunToCompletion( Sensor* pPredicateTop, PredicateStm* pStm );
static void PredicateStm_SensorActive_Entry( Sensor* pSensor, PredicateStm* pStm ){
    if( HdStateMachine_Enterable( &pStm->base, PredicateStm_SensorActive ) ){
        printf( "%s\n", __FUNCTION__ );
        DepedentStm_Reset( pSensor, &pStm->DependentDepedentStm, &pStm->base, STATE_UNDEF );
    }
}
static BOOL PredicateStm_SensorActive_EventProc( Sensor* pSensor, PredicateStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = PredicateStm_SensorActive;
    return bResult;
}
static void PredicateStm_SensorActive_Exit( Sensor* pSensor, PredicateStm* pStm ){
    if( HdStateMachine_Exitable( &pStm->base, PredicateStm_SensorActive ) ){ 
        DepedentStm_Abort( pSensor, &pStm->DependentDepedentStm );
        printf( "%s\n", __FUNCTION__ );
    }
}
static void PredicateStm_WaitingForData_Entry( Sensor* pSensor, PredicateStm* pStm ){
    if( HdStateMachine_Enterable( &pStm->base, PredicateStm_WaitingForData ) ){
        PredicateStm_SensorActive_Entry( pSensor, pStm );
        printf( "%s\n", __FUNCTION__ );
    }
}
static BOOL PredicateStm_WaitingForData_EventProc( Sensor* pSensor, PredicateStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = PredicateStm_WaitingForData;
    switch( nEventId ){
    case Sensor_evDataReady:{
        DisplayMsg("x = .getData();");
        if (Sensor_IsIn( pSensor, LatchStm_NoData )) {
            PredicateStm_BgnTrans( pSensor, pStm, PredicateStm_DataReady, STATE_UNDEF );
            DepedentStm_Reset( pSensor, &pStm->DependentDepedentStm, &pStm->base, LatchStm_HasNewData );
            PredicateStm_EndTrans( pSensor, pStm );
            bResult = TRUE;
        }
        else {
            PredicateStm_BgnTrans( pSensor, pStm, PredicateStm_DataReady, STATE_UNDEF );
            PredicateStm_EndTrans( pSensor, pStm );
            bResult = TRUE;
        }
    } break;
    default: break;
    }
    return bResult ? bResult : PredicateStm_SensorActive_EventProc( pSensor, pStm, nEventId, pEventParams );
}
static void PredicateStm_WaitingForData_Exit( Sensor* pSensor, PredicateStm* pStm ){
    if( HdStateMachine_Exitable( &pStm->base, PredicateStm_WaitingForData ) ){ 
        printf( "%s\n", __FUNCTION__ );
        PredicateStm_SensorActive_Exit( pSensor, pStm );
    }
}
static void PredicateStm_DataReady_Entry( Sensor* pSensor, PredicateStm* pStm ){
    if( HdStateMachine_Enterable( &pStm->base, PredicateStm_DataReady ) ){
        PredicateStm_SensorActive_Entry( pSensor, pStm );
        printf( "%s\n", __FUNCTION__ );
    }
}
static BOOL PredicateStm_DataReady_EventProc( Sensor* pSensor, PredicateStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = PredicateStm_DataReady;
    switch( nEventId ){
    case Sensor_evDataComplete:{
        PredicateStm_BgnTrans( pSensor, pStm, PredicateStm_ResetingSensor, STATE_UNDEF );
        PredicateStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    } break;
    default: break;
    }
    return bResult ? bResult : PredicateStm_SensorActive_EventProc( pSensor, pStm, nEventId, pEventParams );
}
static void PredicateStm_DataReady_Exit( Sensor* pSensor, PredicateStm* pStm ){
    if( HdStateMachine_Exitable( &pStm->base, PredicateStm_DataReady ) ){ 
        printf( "%s\n", __FUNCTION__ );
        PredicateStm_SensorActive_Exit( pSensor, pStm );
    }
}
static void PredicateStm_ResetingSensor_Entry( Sensor* pSensor, PredicateStm* pStm ){
    if( HdStateMachine_Enterable( &pStm->base, PredicateStm_ResetingSensor ) ){
        PredicateStm_SensorActive_Entry( pSensor, pStm );
        printf( "%s\n", __FUNCTION__ );
    }
}
static BOOL PredicateStm_ResetingSensor_EventProc( Sensor* pSensor, PredicateStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = PredicateStm_ResetingSensor;
    switch( nEventId ){
    case Sensor_evSensorReset:{
        PredicateStm_BgnTrans( pSensor, pStm, PredicateStm_WaitingForData, STATE_UNDEF );
        PredicateStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    } break;
    default: break;
    }
    return bResult ? bResult : PredicateStm_SensorActive_EventProc( pSensor, pStm, nEventId, pEventParams );
}
static void PredicateStm_ResetingSensor_Exit( Sensor* pSensor, PredicateStm* pStm ){
    if( HdStateMachine_Exitable( &pStm->base, PredicateStm_ResetingSensor ) ){ 
        printf( "%s\n", __FUNCTION__ );
        PredicateStm_SensorActive_Exit( pSensor, pStm );
    }
}
static void PredicateStm_EndTrans( Sensor *pSensor, PredicateStm* pStm ){
    pStm->base.nCurrentState = pStm->base.nTargetState;
    pStm->base.bIsExternTrans = FALSE;
    switch( pStm->base.nCurrentState ){
    case PredicateStm_SensorActive:PredicateStm_SensorActive_Entry( pSensor, pStm ); break;
    case PredicateStm_WaitingForData:PredicateStm_WaitingForData_Entry( pSensor, pStm ); break;
    case PredicateStm_DataReady:PredicateStm_DataReady_Entry( pSensor, pStm ); break;
    case PredicateStm_ResetingSensor:PredicateStm_ResetingSensor_Entry( pSensor, pStm ); break;
    default: break;
    }
}
static void PredicateStm_BgnTrans( Sensor *pSensor, PredicateStm* pStm, UINT32 targetState, UINT32 initState ){
    pStm->base.nTargetState = targetState;
    pStm->base.nPseudostate = targetState;
    if( initState ){
        pStm->base.nPseudostate = initState;
    }
    switch( pStm->base.nCurrentState ){
    case PredicateStm_SensorActive:PredicateStm_SensorActive_Exit( pSensor, pStm ); break;
    case PredicateStm_WaitingForData:PredicateStm_WaitingForData_Exit( pSensor, pStm ); break;
    case PredicateStm_DataReady:PredicateStm_DataReady_Exit( pSensor, pStm ); break;
    case PredicateStm_ResetingSensor:PredicateStm_ResetingSensor_Exit( pSensor, pStm ); break;
    default: break;
    }
}
static BOOL PredicateStm_StateDefaultTrans( Sensor* pSensor, PredicateStm* pStm ){
    BOOL bResult = FALSE;
    pStm->base.nSourceState = pStm->base.nCurrentState;
    pStm->base.nLCAState = STATE_UNDEF;
    bResult |= DepedentStm_StateDefaultTrans( pSensor, &pStm->DependentDepedentStm );
    do{   if( pStm->base.nCurrentState == PredicateStm_SensorActive && pStm->base.nPseudostate == PredicateStm_InitPt ){
        PredicateStm_BgnTrans( pSensor, pStm, PredicateStm_WaitingForData, STATE_UNDEF );
        PredicateStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    }else if( pStm->base.nCurrentState == PredicateStm_PredicateTop && pStm->base.nPseudostate == PredicateStm_InitPt ){
        PredicateStm_BgnTrans( pSensor, pStm, PredicateStm_SensorActive, PredicateStm_InitPt );
        PredicateStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    }else if( pStm->base.nCurrentState != pStm->base.nPseudostate && IS_IN(pStm->base.nPseudostate, PredicateStm_PredicateTop) ){
        PredicateStm_BgnTrans( pSensor, pStm, pStm->base.nPseudostate, STATE_UNDEF );
        PredicateStm_EndTrans( pSensor, pStm );
        bResult = TRUE;
    }else{
    }   }while( FALSE );
    return bResult;
}
static BOOL PredicateStm_RunToCompletion( Sensor* pSensor, PredicateStm* pStm ){
    BOOL bResult;
    do{
        bResult = PredicateStm_StateDefaultTrans( pSensor, pStm );
    } while ( bResult );
    return bResult;
}
static BOOL PredicateStm_Reset( Sensor* pSensor, PredicateStm* pStm, HdStateMachine* pParentStm, UINT32 nEntryPoint ) {
    pStm->base.pParentStm = pParentStm;
    if( nEntryPoint == NULL ){
        if( PredicateStm_IsFinished( &pStm->base ) ){
            pStm->base.nPseudostate = PredicateStm_InitPt;
        }
    }else{
        if( PredicateStm_IsFinished( &pStm->base ) ){
            pStm->base.nPseudostate = nEntryPoint;
            return FALSE;
        }else{
            pStm->base.nPseudostate = nEntryPoint;
        }
    }
    if( nEntryPoint != STATE_UNDEF && nEntryPoint <= STATE_TOP ){
        DepedentStm_Reset( pSensor, &pStm->DependentDepedentStm, &pStm->base, nEntryPoint );
    }
    return PredicateStm_RunToCompletion( pSensor, pStm );
}
static BOOL PredicateStm_EventProc( Sensor* pSensor, PredicateStm* pStm, Sensor_EVENT nEventId, void* pEventParams ){
    BOOL bResult = FALSE;
    pStm->base.nLCAState = STATE_UNDEF;
    bResult |= DepedentStm_EventProc( pSensor, &pStm->DependentDepedentStm, nEventId, pEventParams );
    switch( pStm->base.nCurrentState ){
    case PredicateStm_SensorActive:             bResult |= PredicateStm_SensorActive_EventProc( pSensor, pStm, nEventId, pEventParams ); break;
    case PredicateStm_WaitingForData:           bResult |= PredicateStm_WaitingForData_EventProc( pSensor, pStm, nEventId, pEventParams ); break;
    case PredicateStm_DataReady:                bResult |= PredicateStm_DataReady_EventProc( pSensor, pStm, nEventId, pEventParams ); break;
    case PredicateStm_ResetingSensor:           bResult |= PredicateStm_ResetingSensor_EventProc( pSensor, pStm, nEventId, pEventParams ); break;
    default: break;
    }
    PredicateStm_RunToCompletion( pSensor, pStm );
    return bResult;
}
static BOOL PredicateStm_IsIn( PredicateStm* pStm, UINT32 nCompositeState ) {
    if( DepedentStm_IsIn( &pStm->DependentDepedentStm, nCompositeState ) ){ return TRUE; }
    if( IS_IN( pStm->base.nCurrentState, nCompositeState ) ){ return TRUE; }
    return FALSE;
}
static BOOL PredicateStm_Abort( Sensor* pSensor, PredicateStm* pStm ) {
    pStm->base.nSourceState = PredicateStm_PredicateTop;
    PredicateStm_BgnTrans( pSensor, pStm, PredicateStm_PredicateTop, STATE_UNDEF );
    PredicateStm_EndTrans( pSensor, pStm );
    return TRUE;
}
int PredicateStm_IsFinished(PredicateStm* pPredicateStm){
    return pPredicateStm->base.nCurrentState == PredicateStm_PredicateTop && pPredicateStm->base.nCurrentState == pPredicateStm->base.nPseudostate;
}
Context* Sensor_Copy( Sensor* pSensor, const Sensor* pSource ){
    Context_Copy( ( Context* )pSensor, ( Context* )pSource );
    pSensor->x = pSource->x;
    return ( Context* )pSensor;
}
BOOL Sensor_EventProc( Sensor* pSensor, Sensor_EVENT nEventId, void* pEventParams ){
    return PredicateStm_EventProc( pSensor, &pSensor->mainStm, nEventId, pEventParams );
}
BOOL Sensor_Start( Sensor* pSensor ){
    PredicateStm_Abort( pSensor, &pSensor->mainStm );
    return PredicateStm_Reset( pSensor, &pSensor->mainStm, NULL, STATE_UNDEF );
}
BOOL Sensor_IsIn( Sensor* pSensor, UINT32 nState ){
    return PredicateStm_IsIn( &pSensor->mainStm, nState );
}
